#include <std_include.hpp>
#include "land.hpp"
#include <rapidjson/document.h>
#include <rapidjson/writer.h>
#include <rapidjson/stringbuffer.h>
#include <evpp/http/context.h>
#include <evpp/http/http_server.h>
#include <evpp/http/service.h>
#include <3rdparty/libevent/include/event2/http.h>
#include <compression.hpp>
#include <configuration.hpp>
#include "tsto/database/database.hpp"
#include "tsto/statistics/statistics.hpp"


namespace tsto::land {

    void Land::handle_proto_whole_land_token(evpp::EventLoop*, const evpp::http::ContextPtr& ctx,
        const evpp::http::HTTPSendResponseCallback& cb) {
        try {
            std::string uri = ctx->uri();
            std::string token;
            std::string user_id;

            size_t token_start = uri.find("/checkToken/") + 11;
            size_t token_end = uri.find("/protoWholeLandToken/");
            if (token_start != std::string::npos && token_end != std::string::npos) {
                token = uri.substr(token_start, token_end - token_start);
            }


            logger::write(logger::LOG_LEVEL_INCOMING, logger::LOG_LABEL_LAND, "[CHECK TOKEN] Request from %s: %s", ctx->remote_ip().data(), ctx->uri().data());

            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_LAND,
                "[CHECK TOKEN] Request params:\n"
                "URI: %s\n"
                "Token: %s",
                ctx->uri().c_str(),
                token.c_str()
            );

            auto& session = tsto::Session::get();


            Data::TokenData response;
            response.set_sessionkey(session.session_key);
            response.set_expirationdate(0);

            logger::write(logger::LOG_LEVEL_RESPONSE, logger::LOG_LABEL_LAND, "[CHECK TOKEN] Sending response for token: %s", token.c_str());

            headers::set_protobuf_response(ctx);
            cb(utils::serialization::serialize_protobuf(response));
        }
        catch (const std::exception& ex) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_LAND, "[CHECK TOKEN] Error: %s", ex.what());
            ctx->set_response_http_code(500);
            cb("");
        }
    }

    void Land::create_blank_town() {
        auto& session = tsto::Session::get();

        session.land_proto.Clear();

        bool use_legacy_mode = utils::configuration::ReadBoolean("Land", "UseLegacyMode", false);
        bool is_anonymous = session.token_user_id.empty() || session.token_user_id.find('@') == std::string::npos;

        //Set the ID to match the user_id from database if available
        std::string email = session.token_user_id;
        std::string user_id;
        auto& db = tsto::database::Database::get_instance();

        if (!email.empty() && db.get_user_id(email, user_id) && !user_id.empty()) {
            session.land_proto.set_id(user_id);
            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                "[LAND] Set user_id in new land proto from database: %s", user_id.c_str());
        }
        else if (use_legacy_mode && is_anonymous) {
            //legacy/non-logged-in users, generate a default ID
            std::string default_id = "default_" + std::to_string(std::time(nullptr));
            session.land_proto.set_id(default_id);
            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                "[LAND] Set default ID for new legacy town: %s", default_id.c_str());
        }

        auto* friend_data = session.land_proto.mutable_frienddata();
        friend_data->set_dataversion(72);
        friend_data->set_haslemontree(false);
        friend_data->set_language(0);
        friend_data->set_level(0);
        friend_data->set_name("");
        friend_data->set_rating(0);
        friend_data->set_boardwalktilecount(0);

        // Email already retrieved above, but handle the case where it's empty
        if (email.empty()) {
            email = "mytown"; // Default value
        }

        std::string land_save_path;
        bool has_save_path = false;

        // Try to get the land_save_path from the database if we have a valid email
        if (!email.empty() && email != "mytown") {
            has_save_path = db.get_land_save_path(email, land_save_path) && !land_save_path.empty();
        }

        // If no land_save_path in database, create a new one
        if (!has_save_path) {
            std::string filename;
            if (use_legacy_mode && is_anonymous) {
                filename = "mytown.pb";
            }
            else if (!user_id.empty()) {
                filename = "anon_" + user_id + ".pb";
            }
            else {
                filename = "mytown.pb";
            }

            land_save_path = "towns/" + filename;

            // Update the database with the new land_save_path if we have a valid email
            if (!email.empty() && email != "mytown") {
                if (db.update_land_save_path(email, land_save_path)) {
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[LAND] Updated land_save_path in database for %s: %s",
                        email.c_str(), land_save_path.c_str());
                }
                else {
                    logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                        "[LAND] Failed to update land_save_path in database for %s",
                        email.c_str());
                }
            }
        }

        int initial_donuts = std::stoi(utils::configuration::ReadString("Server", "InitialDonutAmount", "1000"));

        std::string currency_path;
        if (use_legacy_mode && is_anonymous) {
            currency_path = "towns/currency.txt";
        }
        else {
            // Extract base filename from land_save_path
            std::string filename = land_save_path;
            size_t last_slash = filename.find_last_of("/\\");
            if (last_slash != std::string::npos) {
                filename = filename.substr(last_slash + 1);
            }

            // Remove .pb extension if present
            size_t pb_pos = filename.find(".pb");
            if (pb_pos != std::string::npos) {
                filename = filename.substr(0, pb_pos);
            }

            currency_path = "towns/" + filename + ".txt";
        }

        std::filesystem::create_directories("towns");

        std::ofstream output(currency_path);
        output << initial_donuts;
        output.close();

        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
            "[LAND] Created new blank town for user %s with data version %d and initial donuts: %d",
            email.c_str(), friend_data->dataversion(), initial_donuts);
    }


    bool Land::static_load_town() {
        auto& session = tsto::Session::get();
        auto& db = tsto::database::Database::get_instance();
        std::string filename = session.town_filename;
        std::string email = session.token_user_id;
        std::string town_file_path;

        // Check if we have a valid email and can get the path from the database
        if (!email.empty()) {
            std::string db_path;
            if (db.get_land_save_path(email, db_path) && !db_path.empty()) {
                town_file_path = db_path;
                // Extract just the filename for logging
                filename = town_file_path.substr(town_file_path.find_last_of("/\\") + 1);
                session.town_filename = filename;

                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[LAND] Using database land save path for %s: %s",
                    email.c_str(), town_file_path.c_str());
            }
        }

        // If we couldn't get a path from the database, use the session filename
        if (town_file_path.empty()) {
            if (filename.empty()) {
                filename = "mytown.pb";
                session.town_filename = filename;
                logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                    "[LAND] Using default town file: %s", filename.c_str());
            }

            town_file_path = "towns/" + filename;

            // If we have a valid email, update the database with this path
            if (!email.empty()) {
                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[LAND] Updating database with land save path for %s: %s",
                    email.c_str(), town_file_path.c_str());

                if (db.update_land_save_path(email, town_file_path)) {
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[LAND] Successfully updated land save path in database for %s", email.c_str());
                }
                else {
                    logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                        "[LAND] Failed to update land save path in database for %s", email.c_str());
                }
            }
        }

        logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
            "[LAND] Attempting to load town from: %s", town_file_path.c_str());

        //create towns directory if it doesn't exist
        std::filesystem::create_directories("towns");

        //try to load existing town or create new one
        if (!std::filesystem::exists(town_file_path)) {
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[LAND] No existing town found at %s, creating new town", town_file_path.c_str());
            create_blank_town();
            return save_town();
        }

        try {
            std::ifstream file(town_file_path, std::ios::binary);
            if (!file.is_open()) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[LAND] Failed to open town file: %s", town_file_path.c_str());
                return false;
            }

            std::vector<char> buffer((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
            file.close();

            // Log file size for debugging
            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                "[LAND] Town file size: %zu bytes", buffer.size());

            bool parsed = false;

            // Attempt 1: Direct parsing (standard protobuf)
            if (session.land_proto.ParseFromArray(buffer.data(), static_cast<int>(buffer.size()))) {
                logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                    "[LAND] Successfully loaded town file (direct parse)");
                parsed = true;
            }
            else {
                logger::write(logger::LOG_LEVEL_WARN, logger::LOG_LABEL_GAME,
                    "[LAND] Direct parse failed. Attempting alternative parsing methods.");

                // Attempt 2: TSTO backup format with 12-byte header
                constexpr size_t backup_offset = 0x0C;  // 12 bytes
                if (buffer.size() > backup_offset) {
                    if (session.land_proto.ParseFromArray(buffer.data() + backup_offset,
                        static_cast<int>(buffer.size() - backup_offset))) {
                        logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                            "[LAND] Successfully loaded town file (12-byte offset)");
                        parsed = true;
                    }
                    else {
                        logger::write(logger::LOG_LEVEL_WARN, logger::LOG_LABEL_GAME,
                            "[LAND] 12-byte offset parse failed. Checking for other formats.");

                        // Attempt 3: Try with 16-byte offset (another possible format)
                        constexpr size_t alt_offset = 0x10;  // 16 bytes
                        if (buffer.size() > alt_offset) {
                            if (session.land_proto.ParseFromArray(buffer.data() + alt_offset,
                                static_cast<int>(buffer.size() - alt_offset))) {
                                logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                                    "[LAND] Successfully loaded town file (16-byte offset)");
                                parsed = true;
                            }
                        }

                        // Attempt 4: Try with 4-byte offset (simpler header)
                        if (!parsed && buffer.size() > 4) {
                            if (session.land_proto.ParseFromArray(buffer.data() + 4,
                                static_cast<int>(buffer.size() - 4))) {
                                logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                                    "[LAND] Successfully loaded town file (4-byte offset)");
                                parsed = true;
                            }
                        }
                    }
                }

                // If all parsing attempts failed
                if (!parsed) {
                    // Log first few bytes for debugging
                    std::stringstream hex_dump;
                    hex_dump << "File header: ";
                    size_t bytes_to_show = std::min(buffer.size(), size_t(32));
                    for (size_t i = 0; i < bytes_to_show; i++) {
                        hex_dump << std::hex << std::setw(2) << std::setfill('0')
                            << static_cast<int>(static_cast<unsigned char>(buffer[i])) << " ";
                    }

                    logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                        "[LAND] Failed to parse town file after multiple attempts. %s", hex_dump.str().c_str());

                    // Create a backup of the problematic file for analysis
                    std::string backup_path = town_file_path + ".unparseable";
                    try {
                        std::ofstream backup_file(backup_path, std::ios::binary);
                        if (backup_file.is_open()) {
                            backup_file.write(buffer.data(), buffer.size());
                            backup_file.close();
                            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                                "[LAND] Created backup of unparseable town file: %s", backup_path.c_str());
                        }
                    }
                    catch (const std::exception& e) {
                        logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                            "[LAND] Failed to create backup of unparseable file: %s", e.what());
                    }

                    return false;
                }
            }

            // Update the land proto ID to match the user_id from database
            std::string email = session.token_user_id;
            std::string user_id;
            auto& db = tsto::database::Database::get_instance();

            if (!email.empty() && db.get_user_id(email, user_id) && !user_id.empty()) {
                //logged-in users with a valid user_id, update the land ID
                session.land_proto.set_id(user_id);
                logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                    "[LAND] Updated land_proto ID to match database user_id: %s", user_id.c_str());
            }
            else if (filename == "mytown.pb") {
                // For legacy/non-logged-in users, preserve the existing ID or generate a default one if empty
                if (session.land_proto.id().empty()) {
                    std::string default_id = "default_" + std::to_string(std::time(nullptr));
                    session.land_proto.set_id(default_id);
                    logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                        "[LAND] Set default ID for legacy town: %s", default_id.c_str());
                }
                else {
                    logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                        "[LAND] Preserved existing ID for legacy town: %s", session.land_proto.id().c_str());
                }
            }

            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                "[LAND] Successfully loaded town file: %s", town_file_path.c_str());
            return true;
        }
        catch (const std::exception& ex) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME, "[LAND] Error loading town file: %s", ex.what());
            return false;
        }
    }

    bool Land::instance_load_town() {
        auto& session = tsto::Session::get();
        auto& db = tsto::database::Database::get_instance();

        std::string town_file_path;
        std::string land_save_path;
        bool has_save_path = false;
        std::string email = this->email_;

        // Always prioritize database lookup for registered users
        if (!email.empty()) {
            // First try to get the land save path from the database
            if (db.get_land_save_path(email, land_save_path) && !land_save_path.empty()) {
                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[LAND] Using database land save path for %s: %s",
                    email.c_str(), land_save_path.c_str());
            }
            else {
                // If not found in database, use default path and update the database
                land_save_path = "towns/" + email + ".pb";
                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[LAND] Setting new database land save path for %s: %s",
                    email.c_str(), land_save_path.c_str());

                // Update the database with this path
                if (db.update_land_save_path(email, land_save_path)) {
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[LAND] Successfully updated land save path in database for %s", email.c_str());
                }
                else {
                    logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                        "[LAND] Failed to update land save path in database for %s", email.c_str());
                }
            }

            // Always update the session with the database path
            session.town_filename = land_save_path.substr(land_save_path.find_last_of("/\\") + 1);
            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                "[LAND] Updated session town_filename to: %s", session.town_filename.c_str());
        }
        // For anonymous users
        else {
            // Try to get user_id from the database using email
            std::string user_id;
            if (!email.empty() && db.get_user_id(email, user_id) && !user_id.empty()) {
                std::string anon_id = "anon_" + user_id;
                if (db.get_land_save_path(anon_id, land_save_path) && !land_save_path.empty()) {
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[LAND] Using database land save path for anonymous user: %s",
                        land_save_path.c_str());
                }
                else {
                    // Create a new path for this anonymous user and store it in the database
                    land_save_path = "towns/anon_" + user_id + ".pb";
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[LAND] Setting new database land save path for anonymous user: %s",
                        land_save_path.c_str());

                    if (db.update_land_save_path(anon_id, land_save_path)) {
                        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                            "[LAND] Successfully updated land save path in database for anonymous user");
                    }
                    else {
                        logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                            "[LAND] Failed to update land save path in database for anonymous user");
                    }
                }

                // Update the session with the database path
                session.town_filename = land_save_path.substr(land_save_path.find_last_of("/\\") + 1);
            }
            // Last resort for completely anonymous users with no ID
            else {
                bool use_legacy_mode = utils::configuration::ReadBoolean("Land", "UseLegacyMode", false);

                if (use_legacy_mode) {
                    land_save_path = "towns/mytown.pb";
                    session.town_filename = "mytown.pb";
                    logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                        "[LAND] Using legacy shared filename for anonymous user: %s", land_save_path.c_str());
                }
                else {
                    // Generate a unique ID and store it in the database
                    std::string random_id = "temp_" + std::to_string(std::time(nullptr));
                    land_save_path = "towns/" + random_id + ".pb";
                    session.town_filename = random_id + ".pb";
                    logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                        "[LAND] Using temporary unique filename for anonymous user: %s", land_save_path.c_str());

                    // Store this in the database too
                    if (db.update_land_save_path(random_id, land_save_path)) {
                        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                            "[LAND] Successfully stored temporary land save path in database");
                    }
                }
            }
        }

        // Assign the land_save_path to town_file_path before checking if it exists
        town_file_path = land_save_path;
        logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
            "[LAND] Using town file path: %s", town_file_path.c_str());

        try {
            if (!std::filesystem::exists(town_file_path)) {
                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[LAND] Town file does not exist: %s", town_file_path.c_str());
                return false;
            }

            std::ifstream file(town_file_path, std::ios::binary);
            if (!file.is_open()) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[LAND] Failed to open town file: %s", town_file_path.c_str());
                return false;
            }

            // Read the entire file into a vector
            std::vector<char> buffer((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
            file.close();

            if (buffer.empty()) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[LAND] Town file is empty: %s", town_file_path.c_str());
                return false;
            }

            bool parse_success = false;

            // Try direct parse first
            if (session.land_proto.ParseFromArray(buffer.data(), static_cast<int>(buffer.size()))) {
                logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                    "[LAND] Successfully loaded town file (direct parse)");
                parse_success = true;
            }
            else {
                // Try backup offset parse
                logger::write(logger::LOG_LEVEL_WARN, logger::LOG_LABEL_GAME,
                    "[LAND] Direct parse failed. Attempting Tsto backup offset parse.");

                constexpr size_t backup_offset = 0x0C;
                if (buffer.size() > backup_offset) {
                    if (session.land_proto.ParseFromArray(buffer.data() + backup_offset,
                        static_cast<int>(buffer.size() - backup_offset))) {
                        logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                            "[LAND] Successfully loaded town file (Tsto Backup)");
                        parse_success = true;
                    }
                }
            }

            if (!parse_success) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[LAND] Failed to parse town file after both parse attempts");
                return false;
            }

            // Ensure mayhem ID is set in the land proto
            std::string mayhem_id;
            if (!email.empty() && db.get_mayhem_id(email, mayhem_id) && !mayhem_id.empty()) {
                // Logged-in users with a valid mayhem_id, update the land ID
                session.land_proto.set_id(mayhem_id);
                logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                    "[LAND] Setting mayhem_id in land proto: %s", mayhem_id.c_str());
            }
            else if (land_save_path == "towns/mytown.pb") {
                // For legacy/non-logged-in users, preserve the existing ID or generate a default one if empty
                if (session.land_proto.id().empty()) {
                    std::string default_id = "default_" + std::to_string(std::time(nullptr));
                    session.land_proto.set_id(default_id);
                    logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                        "[LAND] Set default ID for legacy town: %s", default_id.c_str());
                }
                else {
                    logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                        "[LAND] Preserved existing ID for legacy town: %s", session.land_proto.id().c_str());
                }
            }

            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                "[LAND] Successfully loaded town file: %s", town_file_path.c_str());
            return true;
        }
        catch (const std::exception& ex) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME, "[LAND] Error loading town file: %s", ex.what());
            return false;
        }
    }

    bool Land::instance_save_town() {
        if (email_.empty()) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                "[LAND] Email not set for Land instance");
            return false;
        }

        auto& db = tsto::database::Database::get_instance();
        auto& session = tsto::Session::get();

        std::string land_save_path;

        // First try to get the land save path from the database
        if (db.get_land_save_path(email_, land_save_path) && !land_save_path.empty()) {
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[LAND] Using database land save path for saving %s: %s",
                email_.c_str(), land_save_path.c_str());
        }
        else {
            // If not found in database, use default path
            land_save_path = "towns/" + email_ + ".pb";
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[LAND] Using default land save path for saving %s: %s",
                email_.c_str(), land_save_path.c_str());

            // Update the database with this path
            if (!db.update_land_save_path(email_, land_save_path)) {
                logger::write(logger::LOG_LEVEL_WARN, logger::LOG_LABEL_GAME,
                    "[LAND] Failed to update land save path in database for %s", email_.c_str());
            }
        }

        std::filesystem::path town_file_path(land_save_path);
        std::filesystem::create_directories(town_file_path.parent_path());

        try {
            // Serialize the land proto to a string
            std::string serialized;
            if (!session.land_proto.SerializeToString(&serialized)) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[LAND] Failed to serialize land proto for instance save");
                return false;
            }

            // Write the serialized data to the file
            std::ofstream file(town_file_path, std::ios::binary);
            if (!file.is_open()) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[LAND] Failed to open file for writing: %s", town_file_path.string().c_str());
                return false;
            }

            // Use a limited buffer size to prevent memory exhaustion
            const size_t BUFFER_SIZE = 8192; // 8KB chunks
            const char* data = serialized.data();
            size_t remaining = serialized.size();

            while (remaining > 0) {
                size_t chunk_size = std::min(remaining, BUFFER_SIZE);
                file.write(data, chunk_size);
                data += chunk_size;
                remaining -= chunk_size;
            }

            file.close();

            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[LAND] Successfully saved town to: %s (size: %zu bytes)",
                town_file_path.string().c_str(), serialized.size());

            return true;
        }
        catch (const std::exception& ex) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                "[LAND] Error saving town: %s", ex.what());
            return false;
        }
    }

    bool Land::save_town() {
        auto& session = tsto::Session::get();
        auto& db = tsto::database::Database::get_instance();
        std::string email = session.token_user_id;
        std::string filename = session.town_filename;

        // For legacy users or when not logged in
        if (filename.empty()) {
            // Check if we have user_id from database and email
            std::string user_id;
            if (!email.empty() && db.get_user_id(email, user_id) && !user_id.empty()) {
                bool user_is_anonymous = email.find('@') == std::string::npos;
                bool use_legacy_mode = utils::configuration::ReadBoolean("Land", "UseLegacyMode", false);

                if (user_is_anonymous) {
                    if (use_legacy_mode) {
                        // Legacy mode: all anonymous users share the same town file
                        filename = "mytown.pb";
                        logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                            "[LAND] Anonymous user detected, using legacy shared filename: %s",
                            filename.c_str());
                    }
                    else {
                        // Modern mode: each anonymous user gets a unique town file
                        filename = "anon_" + user_id + ".pb";
                        logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                            "[LAND] Anonymous user detected, using unique filename: %s",
                            filename.c_str());
                    }
                }
                else {
                    filename = email + ".pb";
                }
            }
            else {
                // Fallback to default if no user info is available
                filename = "mytown.pb";
                logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                    "[LAND] No user info available, using default town file for saving: %s", filename.c_str());
            }

            session.town_filename = filename;
        }

        // Create towns directory if it doesn't exist
        std::filesystem::create_directories("towns");

        std::string land_save_path = "towns/" + filename;
        logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
            "[LAND] Saving town to: %s", land_save_path.c_str());

        try {
            // Create parent directories if they don't exist
            std::filesystem::path path(land_save_path);
            std::filesystem::create_directories(path.parent_path());

            // Serialize the land proto to a string
            std::string serialized;
            if (!session.land_proto.SerializeToString(&serialized)) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[LAND] Failed to serialize land proto");
                return false;
            }

            // Write the serialized data to the file
            std::ofstream file(land_save_path, std::ios::binary);
            if (!file.is_open()) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[LAND] Failed to open file for writing: %s", land_save_path.c_str());
                return false;
            }

            file.write(serialized.data(), serialized.size());
            file.close();

            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[LAND] Successfully saved town to: %s (size: %zu bytes)",
                land_save_path.c_str(), serialized.size());

            return true;
        }
        catch (const std::exception& ex) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                "[LAND] Error saving town: %s", ex.what());
            return false;
        }
    }

    void Land::handle_get_request(const evpp::http::ContextPtr& ctx, const evpp::http::HTTPSendResponseCallback& cb, const std::string& land_id) {
        auto& session = tsto::Session::get();
        auto& db = tsto::database::Database::get_instance();
        std::string email;
        bool user_found = false;

        // First priority: Check if we can find a user by the mayhem ID in the URL
        std::string mayhem_id_from_url = land_id; // The land_id from the URL is the mayhem ID
        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
            "[PROTOLAND] Attempting to match user by mayhem ID from URL: %s", mayhem_id_from_url.c_str());

        if (db.get_email_by_mayhem_id(mayhem_id_from_url, email)) {
            // Found a user with this mayhem ID from URL
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[PROTOLAND] Found user by mayhem ID from URL in GET request: %s -> %s",
                mayhem_id_from_url.c_str(), email.c_str());
            user_found = true;
        }

        // Second priority: Check if we have a mh_uid header to help identify the correct user
        if (!user_found) {
            const char* mh_uid_header = ctx->FindRequestHeader("mh_uid");
            if (mh_uid_header) {
                std::string requested_user_id = mh_uid_header;
                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] Found mh_uid header: %s", requested_user_id.c_str());

                // First try to find user by mh_uid header value (user_id)
                std::string user_id_email;
                if (db.get_email_by_user_id(requested_user_id, user_id_email)) {
                    // Found a user with this user ID from mh_uid header
                    email = user_id_email;
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[PROTOLAND] Found user by user ID from mh_uid header in GET request: %s -> %s",
                        requested_user_id.c_str(), email.c_str());
                    user_found = true;
                }

                // If not found by user ID, try by mayhem ID
                if (!user_found) {
                    std::string mayhem_email;
                    if (db.get_email_by_mayhem_id(requested_user_id, mayhem_email)) {
                        // Found a user with this mayhem ID from mh_uid header
                        email = mayhem_email;
                        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                            "[PROTOLAND] Found user by mayhem ID from mh_uid header in GET request: %s -> %s",
                            requested_user_id.c_str(), email.c_str());
                        user_found = true;
                    }
                }
            }
        }

        // Last priority: Try to find user by access token
        if (!user_found) {
            const char* auth_header = ctx->FindRequestHeader("mh_auth_params");
            if (!auth_header) {
                auth_header = ctx->FindRequestHeader("nucleus_token");
            }

            if (auth_header) {
                std::string access_token = auth_header;
                if (db.get_email_by_token(access_token, email)) {
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[PROTOLAND] Found user by access token in GET request: %s", email.c_str());
                    user_found = true;
                    session.access_token = access_token;
                }
            }
        }

        // If no user found by any method, log warning and continue in anonymous mode
        if (!user_found) {
            logger::write(logger::LOG_LEVEL_WARN, logger::LOG_LABEL_GAME,
                "[PROTOLAND] GET request with no user/mayhem ID match, using anonymous mode for land_id: %s",
                land_id.c_str());
        }

        // Set up the land instance with the authenticated email
        Land land_instance;
        if (user_found) {
            // Get the user_id associated with this email
            std::string user_id;
            if (db.get_user_id(email, user_id)) {
                // Important: Use the email directly for loading the town rather than relying on session
                land_instance.set_email(email);

                // Always check the database for the land save path using the email from this request
                std::string land_save_path;
                if (db.get_land_save_path(email, land_save_path) && !land_save_path.empty()) {
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[PROTOLAND] Using database land save path for GET request: %s: %s",
                        email.c_str(), land_save_path.c_str());
                }
                else {
                    // If not found in database, create and store a default path
                    land_save_path = "towns/" + email + ".pb";
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[PROTOLAND] Setting new database land save path for GET request: %s: %s",
                        email.c_str(), land_save_path.c_str());

                    if (db.update_land_save_path(email, land_save_path)) {
                        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                            "[PROTOLAND] Successfully updated land save path in database for GET request: %s", email.c_str());
                    }
                    else {
                        logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                            "[PROTOLAND] Failed to update land save path in database for GET request: %s", email.c_str());
                    }
                }

                // Load the town directly using the path from the database
                // rather than relying on session state which might be stale
                std::ifstream file(land_save_path, std::ios::binary);
                if (file.is_open()) {
                    std::vector<char> buffer((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
                    file.close();

                    if (!buffer.empty()) {
                        // Try to parse the town data
                        bool parsed = false;
                        if (session.land_proto.ParseFromArray(buffer.data(), static_cast<int>(buffer.size()))) {
                            parsed = true;
                            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                                "[PROTOLAND] Successfully loaded town file directly (direct parse): %s", land_save_path.c_str());
                        }
                        else {
                            // Try with various offsets as in static_load_town
                            constexpr size_t backup_offset = 0x0C;  // 12 bytes
                            if (buffer.size() > backup_offset) {
                                if (session.land_proto.ParseFromArray(buffer.data() + backup_offset,
                                    static_cast<int>(buffer.size() - backup_offset))) {
                                    parsed = true;
                                    logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                                        "[PROTOLAND] Successfully loaded town file directly (12-byte offset): %s", land_save_path.c_str());
                                }
                            }
                        }

                        if (parsed) {
                            // Successfully loaded the town, update session for compatibility with other code
                            session.token_user_id = email;
                            // No need to update session.user_user_id, using database directly
                            // No longer using session.town_filename - using database land_save_path instead

                            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                                "[PROTOLAND] GET request successfully loaded town directly for: %s (user_id: %s)",
                                email.c_str(), user_id.c_str());

                            // Skip instance_load_town since we've already loaded the town
                            headers::set_protobuf_response(ctx);
                            std::string serialized;
                            session.land_proto.SerializeToString(&serialized);
                            cb(serialized);
                            return;
                        }
                    }
                }

                // If direct loading failed, fall back to instance_load_town
                // but still update the session for compatibility
                session.token_user_id = email;
                // No need to update session.user_user_id, using database directly
                // No longer using session.town_filename - using database land_save_path instead

                logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] GET request using authenticated email: %s (user_id: %s) for land_id: %s, land_save_path: %s",
                    email.c_str(), user_id.c_str(), land_id.c_str(), land_save_path.c_str());
            }
        }

        // Fall back to instance_load_town if direct loading failed or user not found
        if (!land_instance.instance_load_town()) {
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[PROTOLAND] Town not found, creating blank town for land_id: %s",
                land_id.c_str());
            create_blank_town();
        }

        logger::write(logger::LOG_LEVEL_RESPONSE, logger::LOG_LABEL_GAME,
            "[PROTOLAND] Sending land data for land_id: %s", land_id.c_str());

        headers::set_protobuf_response(ctx);
        std::string serialized;
        session.land_proto.SerializeToString(&serialized);
        cb(serialized);
    }

    void Land::handle_protoland(evpp::EventLoop*, const evpp::http::ContextPtr& ctx,
        const evpp::http::HTTPSendResponseCallback& cb) {
        try {
            const std::string uri = ctx->uri();
            const size_t land_start = uri.find("/protoland/") + 11;
            const size_t land_end = uri.find("/", land_start);

            if (land_start == std::string::npos || land_end == std::string::npos || land_end <= land_start) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] Invalid URI format: %s", uri.c_str());
                ctx->set_response_http_code(400);
                cb("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error code=\"400\" type=\"BAD_REQUEST\" field=\"Invalid URI format\"/>");
                return;
            }

            const std::string land_id = uri.substr(land_start, land_end - land_start);

            // Extract access token from headers (case-insensitive) - consistent with JavaScript implementation
            std::string access_token;
            const char* auth_header = nullptr;

            // Check nucleus_token header first (primary token in JS implementation)
            auth_header = ctx->FindRequestHeader("nucleus_token");
            if (auth_header) {
                access_token = auth_header;
            }

            // Fall back to mh_auth_params if nucleus_token is not present
            if (access_token.empty()) {
                auth_header = ctx->FindRequestHeader("mh_auth_params");
                if (auth_header) {
                    std::string auth_str(auth_header);
                    if (auth_str.substr(0, 7) == "Bearer ") {
                        access_token = auth_str.substr(7);
                    }
                    else {
                        access_token = auth_str;
                    }
                }
            }

            // Fall back to access_token as last resort
            if (access_token.empty()) {
                auth_header = ctx->FindRequestHeader("access_token");
                if (auth_header) {
                    access_token = auth_header;
                }
            }

            // Check if we have a valid access token
            if (access_token.empty()) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] No access token provided in request");
                ctx->set_response_http_code(401); // Changed to 401 for consistency
                cb("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error code=\"401\" type=\"MISSING_VALUE\" field=\"nucleus_token\"/>");
                return;
            }

            auto& session = tsto::Session::get();
            auto& db = tsto::database::Database::get_instance();

            // Store the access token in the session
            session.access_token = access_token;

            // First try to find user by mayhem ID from URL (highest priority)
            std::string email;
            bool user_found = false;
            std::string mayhem_id_from_url = land_id; // The land_id from the URL is the mayhem ID

            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[PROTOLAND] Attempting to match user by mayhem ID from URL: %s", mayhem_id_from_url.c_str());

            if (db.get_email_by_mayhem_id(mayhem_id_from_url, email)) {
                // Found a user with this mayhem ID from URL
                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] Found user by mayhem ID from URL: %s -> %s",
                    mayhem_id_from_url.c_str(), email.c_str());
                user_found = true;
            }

            // Second priority: Check if we have a mh_uid header to identify the user
            if (!user_found) {
                const char* mh_uid_header = ctx->FindRequestHeader("mh_uid");
                if (mh_uid_header) {
                    std::string requested_user_id = mh_uid_header;
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[PROTOLAND] Found mh_uid header: %s", requested_user_id.c_str());

                    // Try to find user by mh_uid header value (user_id)
                    std::string user_id_email;
                    if (db.get_email_by_user_id(requested_user_id, user_id_email)) {
                        // Found a user with this user ID from mh_uid header
                        email = user_id_email;
                        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                            "[PROTOLAND] Found user by user ID from mh_uid header: %s -> %s",
                            requested_user_id.c_str(), email.c_str());
                        user_found = true;
                    }
                }
            }

            // Last priority: Try to find user by access token
            if (!user_found) {
                if (db.get_email_by_token(access_token, email)) {
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[PROTOLAND] Found user by access token: %s", email.c_str());
                    user_found = true;
                }
            }

            // If no user found by any method, return error
            if (!user_found) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] Could not find user by mayhem ID, mh_uid header, or access token");
                ctx->set_response_http_code(403);
                cb("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error code=\"403\" type=\"BAD_REQUEST\" field=\"Invalid AccessToken, User ID, or Mayhem ID\"/>");
                return;
            }
            else {
                // IP verification has been removed as requested
                logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] Skipping IP verification for user: %s", email.c_str());
            }

            // Check if anonymous users are allowed
            bool allow_anonymous_users = !utils::configuration::ReadBoolean("Security", "DisableAnonymousUsers", false);

            // Check if this is an anonymous user (email doesn't contain @)
            bool user_is_anonymous = email.find('@') == std::string::npos;

            if (user_is_anonymous && !allow_anonymous_users) {
                logger::write(logger::LOG_LEVEL_WARN, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] Anonymous user rejected (anonymous users disabled): %s", email.c_str());
                ctx->set_response_http_code(400);
                cb("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error code=\"200\" type=\"BAD_REQUEST\" field=\"Anonymous users are not allowed\"/>");
                return;
            }

            // Get the user_id associated with this email
            std::string user_id;
            if (!db.get_user_id(email, user_id)) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] No user_id found for email: %s", email.c_str());
                ctx->set_response_http_code(404);
                cb("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error code=\"404\" type=\"NOT_FOUND\" field=\"user_id\"/>");
                return;
            }

            // Handle potential land_id vs user_id mismatch
            if (land_id != user_id && ctx->FindRequestHeader("mh_uid")) {
                logger::write(logger::LOG_LEVEL_WARN, logger::LOG_LABEL_LAND,
                    "[PROTOLAND] Land ID mismatch - URI: %s, user_id: %s",
                    land_id.c_str(), user_id.c_str());

                // Check if the land_id is a valid user ID in our system
                std::string land_email;
                if (db.get_email_by_user_id(land_id, land_email)) {
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_LAND,
                        "[PROTOLAND] Found valid email for land_id: %s -> %s",
                        land_id.c_str(), land_email.c_str());

                    // Update the session and continue with the valid user
                    email = land_email;
                    session.token_user_id = email;

                    // Check if we need to update the token in the database
                    std::string stored_token;
                    if (db.get_access_token(email, stored_token) && stored_token != access_token) {
                        // Update the token in the database
                        if (db.update_access_token(email, access_token)) {
                            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_LAND,
                                "[PROTOLAND] Updated access token for user: %s", email.c_str());
                        }
                    }
                }
                else {
                    // If we can't find a valid user for the land_id, reject the request
                    logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_LAND,
                        "[PROTOLAND] Land ID mismatch and no valid user found - URI: %s, user_id: %s",
                        land_id.c_str(), user_id.c_str());
                    ctx->set_response_http_code(403);
                    cb("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error code=\"403\" type=\"BAD_REQUEST\" field=\"Invalid Land ID for specified AccessToken\"/>");
                    return;
                }
            }

            // Skip strict token validation - only validate based on mayhem ID from URL and user_id from mh_uid header
            // This allows clients with different tokens to access the land as long as they have the correct mayhem ID or user ID
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_LAND,
                "[PROTOLAND] Skipping strict token validation for user: %s (using mayhem ID/user_id validation instead)", email.c_str());

            // Store the email and token in the session for later use
            session.token_user_id = email;
            // No need to update session.user_user_id, using database directly

            // Set the correct town filename based on the authenticated user's email
            bool use_legacy_mode = utils::configuration::ReadBoolean("Land", "UseLegacyMode", false);

            if (user_is_anonymous) {
                if (use_legacy_mode) {
                    // Legacy mode: all anonymous users share the same town file
                    session.town_filename = "mytown.pb";
                    logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                        "[PROTOLAND] Anonymous user detected, using legacy shared filename: %s",
                        session.town_filename.c_str());
                }
                else {
                    // Modern mode: each anonymous user gets a unique town file
                    session.town_filename = "anon_" + user_id + ".pb";
                    logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                        "[PROTOLAND] Anonymous user detected, using unique filename: %s",
                        session.town_filename.c_str());
                }
            }
            else {
                session.town_filename = email + ".pb";
            }

            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                "[PROTOLAND] Request from %s for land_id: %s, using town file: %s",
                ctx->remote_ip().c_str(), land_id.c_str(), session.town_filename.c_str());

            const std::string method = ctx->GetMethod();
            if (method == "GET") {
                Land instance;
                instance.set_email(email);
                logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] GET request using email: %s for land_id: %s",
                    email.c_str(), land_id.c_str());

                // IP verification has been removed as requested
                logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] Skipping IP verification for GET request for user: %s", email.c_str());

                // Load the town for this user
                if (instance.instance_load_town()) {
                    logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                        "[PROTOLAND] Successfully loaded town for %s", email.c_str());

                    // Return the land data
                    auto& session = tsto::Session::get();
                    std::string serialized;
                    if (session.land_proto.SerializeToString(&serialized)) {
                        headers::set_protobuf_response(ctx);
                        cb(serialized);
                        return;
                    }
                    else {
                        logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                            "[PROTOLAND] Failed to serialize land data for %s", email.c_str());
                    }
                }
                else {
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[PROTOLAND] Town not found for %s, creating blank town", email.c_str());

                    // Create a blank town
                    create_blank_town();

                    // Save the blank town
                    if (save_town()) {
                        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                            "[PROTOLAND] Successfully created and saved blank town for %s", email.c_str());

                        // Return the land data
                        auto& session = tsto::Session::get();
                        std::string serialized;
                        if (session.land_proto.SerializeToString(&serialized)) {
                            headers::set_protobuf_response(ctx);
                            cb(serialized);
                            return;
                        }
                        else {
                            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                                "[PROTOLAND] Failed to serialize land data for blank town for %s", email.c_str());
                        }
                    }
                    else {
                        logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                            "[PROTOLAND] Failed to save blank town for %s", email.c_str());
                    }
                }
            }
            else if (method == "PUT") {
                handle_put_request(ctx, cb);
            }
            else if (method == "POST") {
                handle_post_request(ctx, cb);
            }
            else {
                ctx->set_response_http_code(405);
                ctx->AddResponseHeader("Allow", "GET, PUT, POST");
                cb("Method Not Allowed");
            }
        }
        catch (const std::exception& ex) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                "[PROTOLAND] Error: %s", ex.what());
            ctx->set_response_http_code(500);
            cb("");
        }
    }

    void Land::handle_put_request(const evpp::http::ContextPtr& ctx, const evpp::http::HTTPSendResponseCallback& cb) {
        // Extract and validate access token from headers
        const char* auth_header = ctx->FindRequestHeader("mh_auth_params");
        if (!auth_header) {
            auth_header = ctx->FindRequestHeader("nucleus_token");
            if (!auth_header) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] Missing authentication token");
                ctx->set_response_http_code(401);
                cb("Authentication required");
                return;
            }
        }

        // Extract token from header
        std::string access_token = auth_header;

        // Get email from token
        auto& db = tsto::database::Database::get_instance();
        std::string email;
        if (!db.get_email_by_token(access_token, email)) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_LAND,
                "[PROTOLAND] Invalid access token in PUT request: %s", access_token.c_str());
            ctx->set_response_http_code(403);
            cb("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error code=\"403\" type=\"BAD_REQUEST\" field=\"Invalid AccessToken\"/>");
            return;
        }

        // Store the email and token in the session for later use
        auto& session = tsto::Session::get();
        session.token_user_id = email;
        session.access_token = access_token;

        const evpp::Slice& body = ctx->body();
        logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME, "[PROTOLAND] Body size: %zu", body.size());

        if (body.empty()) {
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME, "[PROTOLAND] Creating new empty town");
            create_blank_town();
            if (!save_town()) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME, "[PROTOLAND] Failed to save empty town");
                ctx->set_response_http_code(500);
                cb("Failed to save empty town");
                return;
            }
        }
        else {
            if (!session.land_proto.ParseFromArray(body.data(), body.size())) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME, "[PROTOLAND] Failed to parse request body");
                ctx->set_response_http_code(400);
                cb("Failed to parse body");
                return;
            }

            if (!save_town()) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME, "[PROTOLAND] Failed to save town data");
                ctx->set_response_http_code(500);
                cb("Failed to save town data");
                return;
            }
        }

        headers::set_protobuf_response(ctx);
        std::string serialized;
        if (!tsto::Session::get().land_proto.SerializeToString(&serialized)) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME, "[PROTOLAND] Failed to serialize response");
            ctx->set_response_http_code(500);
            cb("Failed to serialize response");
            return;
        }
        cb(serialized);
    }

    void Land::handle_post_request(const evpp::http::ContextPtr& ctx, const evpp::http::HTTPSendResponseCallback& cb) {
        try {
            auto& session = tsto::Session::get();
            auto& db = tsto::database::Database::get_instance();
            std::string email;
            std::string access_token;
            bool user_found = false;

            // First priority: Check if we can find a user by the mayhem ID from the URI
            std::string uri = ctx->uri();
            const size_t land_start = uri.find("/protoland/") + 11;
            const size_t land_end = uri.find("/", land_start);

            if (land_start != std::string::npos && land_end != std::string::npos && land_end > land_start) {
                std::string mayhem_id_from_url = uri.substr(land_start, land_end - land_start);
                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] Attempting to match user by mayhem ID from URL: %s", mayhem_id_from_url.c_str());

                if (db.get_email_by_mayhem_id(mayhem_id_from_url, email)) {
                    // Found a user with this mayhem ID from URL
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[PROTOLAND] Found user by mayhem ID from URL in POST request: %s -> %s",
                        mayhem_id_from_url.c_str(), email.c_str());
                    user_found = true;
                }
            }

            // Second priority: Check if we have a mh_uid header to help identify the correct user
            if (!user_found) {
                const char* mh_uid_header = ctx->FindRequestHeader("mh_uid");
                if (mh_uid_header) {
                    std::string requested_user_id = mh_uid_header;
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[PROTOLAND] Found mh_uid header: %s", requested_user_id.c_str());

                    // First try to find user by mh_uid header value (user_id)
                    std::string user_id_email;
                    if (db.get_email_by_user_id(requested_user_id, user_id_email)) {
                        // Found a user with this user ID from mh_uid header
                        email = user_id_email;
                        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                            "[PROTOLAND] Found user by user ID from mh_uid header in POST request: %s -> %s",
                            requested_user_id.c_str(), email.c_str());
                        user_found = true;
                    }

                    // If not found by user ID, try by mayhem ID
                    if (!user_found) {
                        std::string mayhem_email;
                        if (db.get_email_by_mayhem_id(requested_user_id, mayhem_email)) {
                            // Found a user with this mayhem ID from mh_uid header
                            email = mayhem_email;
                            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                                "[PROTOLAND] Found user by mayhem ID from mh_uid header in POST request: %s -> %s",
                                requested_user_id.c_str(), email.c_str());
                            user_found = true;
                        }
                    }
                }
            }

            // Last priority: Try to find user by access token
            if (!user_found) {
                const char* auth_header = ctx->FindRequestHeader("mh_auth_params");
                if (!auth_header) {
                    auth_header = ctx->FindRequestHeader("nucleus_token");
                }

                if (auth_header) {
                    access_token = auth_header;
                    if (db.get_email_by_token(access_token, email)) {
                        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                            "[PROTOLAND] Found user by access token in POST request: %s", email.c_str());
                        user_found = true;
                        session.access_token = access_token;
                    }
                }
            }

            // If no user found by any method, return error
            if (!user_found) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] No valid user found for POST request");
                ctx->set_response_http_code(403);
                cb("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error code=\"403\" type=\"BAD_REQUEST\" field=\"Invalid AccessToken, User ID, or Mayhem ID\"/>");
                return;
            }

            // Get the user_id associated with this email
            std::string user_id;
            if (!db.get_user_id(email, user_id)) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] No user_id found for email in POST request: %s", email.c_str());
                ctx->set_response_http_code(404);
                cb("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error code=\"404\" type=\"NOT_FOUND\" field=\"user_id\"/>");
                return;
            }

            // Skip strict token validation - only validate based on mayhem ID from URL and user_id from mh_uid header
            // This allows clients with different tokens to access the land as long as they have the correct mayhem ID or user ID
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_LAND,
                "[PROTOLAND] Skipping strict token validation for user in POST request: %s (using mayhem ID/user_id validation instead)", email.c_str());

            // Get the land save path directly from the database using the email from this request
            std::string land_save_path;
            if (!db.get_land_save_path(email, land_save_path) || land_save_path.empty()) {
                // If not found in database, create and store a default path
                bool use_legacy_mode = utils::configuration::ReadBoolean("Land", "UseLegacyMode", false);
                bool user_is_anonymous = email.find('@') == std::string::npos;

                if (user_is_anonymous) {
                    if (use_legacy_mode) {
                        // Legacy mode: all anonymous users share the same town file
                        land_save_path = "towns/mytown.pb";
                    }
                    else {
                        // Modern mode: each anonymous user gets a unique town file
                        land_save_path = "towns/anon_" + user_id + ".pb";
                    }
                }
                else {
                    land_save_path = "towns/" + email + ".pb";
                }

                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] Setting new database land save path for POST request: %s: %s",
                    email.c_str(), land_save_path.c_str());

                if (db.update_land_save_path(email, land_save_path)) {
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[PROTOLAND] Successfully updated land save path in database for POST request: %s", email.c_str());
                }
                else {
                    logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                        "[PROTOLAND] Failed to update land save path in database for POST request: %s", email.c_str());
                }
            }
            else {
                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] Using database land save path for POST request: %s: %s",
                    email.c_str(), land_save_path.c_str());
            }

            // Extract just the filename from the path
            std::string filename = land_save_path.substr(land_save_path.find_last_of("/\\") + 1);

            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                "[PROTOLAND] Using town filename from database: %s", filename.c_str());

            // Only update session values after we've determined the correct path
            // This ensures we're not relying on potentially stale session data
            session.token_user_id = email;
            // No need to update session.user_user_id, using database directly
            session.access_token = access_token;
            session.town_filename = filename;

            const std::string compressed_data = ctx->body().ToString();
            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                "[PROTOLAND] Received compressed data size: %zu", compressed_data.size());

            std::string decompressed_data;
            const char* encoding = ctx->FindRequestHeader("Content-Encoding");
            if (encoding && strcmp(encoding, "gzip") == 0) {
                decompressed_data = utils::compression::zlib::decompress(compressed_data);
                if (decompressed_data.empty()) {
                    logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                        "[PROTOLAND] Failed to decompress data");
                    ctx->set_response_http_code(400);
                    cb("Failed to decompress data");
                    return;
                }
            }
            else {
                decompressed_data = compressed_data;
            }

            if (!session.land_proto.ParseFromString(decompressed_data)) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] Failed to parse decompressed data");
                ctx->set_response_http_code(400);
                cb("Failed to parse data");
                return;
            }

            if (!user_id.empty()) {
                session.land_proto.set_id(user_id);
            }

            if (!save_town()) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[PROTOLAND] Failed to save land data");
                ctx->set_response_http_code(500);
                cb("Failed to save data");
                return;
            }

            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_LAND,
                "[PROTOLAND] Successfully saved land data for user: %s",
                session.user_user_id.c_str());

            const std::string xml = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>"
                "<WholeLandUpdateResponse/>";

            ctx->AddResponseHeader("Content-Type", "application/xml");
            cb(xml);
        }
        catch (const std::exception& ex) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                "[PROTOLAND] Error processing request: %s", ex.what());
            ctx->set_response_http_code(500);
            cb("Internal server error");
        }
    }

    void Land::handle_delete_token(evpp::EventLoop*, const evpp::http::ContextPtr& ctx,
        const evpp::http::HTTPSendResponseCallback& cb) {
        try {
            std::string remote_ip = std::string(ctx->remote_ip());
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_LAND,
                "[DELETE TOKEN] Received request: RemoteIP: '%s', URI: '%s'",
                remote_ip.c_str(),
                std::string(ctx->uri()).c_str());

            std::string uri = ctx->uri();
            size_t mayhem_id_start = uri.find("/deleteToken/");
            if (mayhem_id_start == std::string::npos) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_LAND,
                    "[DELETE TOKEN] Invalid URI format - could not find /deleteToken/");
                headers::set_xml_response(ctx);
                ctx->set_response_http_code(400);
                cb("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error code=\"400\" type=\"BAD_REQUEST\" field=\"Invalid URI format\"/>");
                return;
            }

            mayhem_id_start += 12; // Skip "/deleteToken/"
            size_t mayhem_id_end = uri.find("/", mayhem_id_start);
            if (mayhem_id_end == std::string::npos) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_LAND,
                    "[DELETE TOKEN] Invalid URI format - could not find end of mayhem_id");
                headers::set_xml_response(ctx);
                ctx->set_response_http_code(400);
                cb("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error code=\"400\" type=\"BAD_REQUEST\" field=\"Invalid URI format\"/>");
                return;
            }

            std::string mayhem_id_str = uri.substr(mayhem_id_start, mayhem_id_end - mayhem_id_start);
            // Handle the mayhem_id format more gracefully
            // Don't try to convert to int64_t if it's not necessary
            // Just use the string representation for comparison with headers
            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_LAND,
                "[DELETE TOKEN] Extracted mayhem_id: %s", mayhem_id_str.c_str());

            const char* mh_uid = ctx->FindRequestHeader("mh_uid");
            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_LAND,
                "[DELETE TOKEN] mh_uid header: %s", mh_uid ? mh_uid : "not found");

            if (!mh_uid || mayhem_id_str != mh_uid) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_LAND,
                    "[DELETE TOKEN] mh_uid mismatch or missing. Expected: %s, Got: %s",
                    mayhem_id_str.c_str(), mh_uid ? mh_uid : "null");
                headers::set_xml_response(ctx);
                ctx->set_response_http_code(404);
                cb("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error code=\"404\" type=\"NOT_FOUND\" field=\"mayhemId\"/>");
                return;
            }

            const char* auth_header = ctx->FindRequestHeader("mh_auth_params");
            if (!auth_header) {
                auth_header = ctx->FindRequestHeader("nucleus_token");
            }

            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_LAND,
                "[DELETE TOKEN] Auth header present: %s", auth_header ? "yes" : "no");

            if (!auth_header) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_LAND,
                    "[DELETE TOKEN] Missing authentication token");
                headers::set_xml_response(ctx);
                ctx->set_response_http_code(400);
                cb("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error code=\"400\" type=\"MISSING_VALUE\" field=\"nucleus_token\"/>");
                return;
            }

            auto& session = tsto::Session::get();

            const evpp::Slice& body = ctx->body();
            Data::DeleteTokenRequest request;

            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_LAND,
                "[DELETE TOKEN] Request body size: %zu bytes", body.size());

            if (!request.ParseFromArray(body.data(), body.size())) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_LAND,
                    "[DELETE TOKEN] Failed to parse delete token request");
                headers::set_xml_response(ctx);
                ctx->set_response_http_code(400);
                cb("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error code=\"400\" type=\"BAD_REQUEST\" field=\"Invalid request format\"/>");
                return;
            }

            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_LAND,
                "[DELETE TOKEN] Request token: %s", request.token().c_str());
            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_LAND,
                "[DELETE TOKEN] Land token: %s", session.land_token.c_str());
            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_LAND,
                "[DELETE TOKEN] Session key: %s", session.session_key.c_str());

            if (request.token() != session.land_token && request.token() != session.session_key) {
                Data::DeleteTokenResponse response;
                response.set_result("0");
                headers::set_protobuf_response(ctx);
                std::string serialized;
                response.SerializeToString(&serialized);
                cb(serialized);
                return;
            }

            session.land_token.clear();
            session.session_key.clear();
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[DELETE TOKEN] Successfully deleted token");

            // Unregister this client IP as it's disconnecting
            tsto::statistics::Statistics::get_instance().unregister_client_ip(remote_ip);

            Data::DeleteTokenResponse response;
            response.set_result("1");
            headers::set_protobuf_response(ctx);
            std::string serialized;
            response.SerializeToString(&serialized);
            cb(serialized);
        }
        catch (const std::exception& ex) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_LAND,
                "[DELETE TOKEN] Error in delete token request: %s", ex.what());
            headers::set_xml_response(ctx);
            ctx->set_response_http_code(500);
            cb("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error code=\"500\" type=\"INTERNAL_SERVER_ERROR\"/>");
        }
    }


    void Land::handle_extraland_update(evpp::EventLoop* loop, const evpp::http::ContextPtr& ctx,
        const evpp::http::HTTPSendResponseCallback& cb, const std::string& land_id) {
        try {
            logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                "[CURRENCY] Processing extraland update for land_id: %s", land_id.c_str());

            std::string body = ctx->body().ToString();
            Data::ExtraLandMessage extraland_msg;
            if (!extraland_msg.ParseFromString(body)) {
                throw std::runtime_error("Failed to parse ExtraLandMessage");
            }

            // Get the current session
            auto& session = tsto::Session::get();
            auto& db = tsto::database::Database::get_instance();
            std::string email;
            std::string access_token;
            bool user_found = false;

            // First priority: Check if we can find a user by the mayhem ID from the URI (land_id)
            if (!land_id.empty()) {
                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[CURRENCY] Attempting to match user by mayhem ID from URL: %s", land_id.c_str());

                if (db.get_email_by_mayhem_id(land_id, email)) {
                    // Found a user with this mayhem ID from URL
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[CURRENCY] Found user by mayhem ID from URL: %s -> %s",
                        land_id.c_str(), email.c_str());
                    user_found = true;
                }
            }

            // Second priority: Check if we have a mh_uid header to help identify the correct user
            if (!user_found) {
                const char* mh_uid_header = ctx->FindRequestHeader("mh_uid");
                if (mh_uid_header) {
                    std::string requested_user_id = mh_uid_header;
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[CURRENCY] Found mh_uid header: %s", requested_user_id.c_str());

                    // First try to find user by mh_uid header value (user_id)
                    std::string user_id_email;
                    if (db.get_email_by_user_id(requested_user_id, user_id_email)) {
                        // Found a user with this user ID from mh_uid header
                        email = user_id_email;
                        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                            "[CURRENCY] Found user by user ID from mh_uid header: %s -> %s",
                            requested_user_id.c_str(), email.c_str());
                        user_found = true;
                    }

                    // If not found by user ID, try by mayhem ID
                    if (!user_found) {
                        std::string mayhem_email;
                        if (db.get_email_by_mayhem_id(requested_user_id, mayhem_email)) {
                            // Found a user with this mayhem ID from mh_uid header
                            email = mayhem_email;
                            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                                "[CURRENCY] Found user by mayhem ID from mh_uid header: %s -> %s",
                                requested_user_id.c_str(), email.c_str());
                            user_found = true;
                        }
                    }
                }
            }

            // Last priority: Try to find user by access token
            if (!user_found) {
                const char* auth_header = ctx->FindRequestHeader("mh_auth_params");
                if (!auth_header) {
                    auth_header = ctx->FindRequestHeader("nucleus_token");
                }

                if (auth_header) {
                    access_token = auth_header;
                    if (db.get_email_by_token(access_token, email)) {
                        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                            "[CURRENCY] Found user by access token: %s", email.c_str());
                        user_found = true;
                        session.access_token = access_token;
                    }
                }
            }

            // If no user found by any method, return error
            if (!user_found) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[CURRENCY] No valid user found for extraland update");
                ctx->set_response_http_code(403);
                cb("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error code=\"403\" type=\"BAD_REQUEST\" field=\"Invalid AccessToken, User ID, or Mayhem ID\"/>");
                return;
            }

            // Get the user_id associated with this email
            std::string user_id;
            if (!db.get_user_id(email, user_id)) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[CURRENCY] No user_id found for email: %s", email.c_str());
                ctx->set_response_http_code(404);
                cb("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<error code=\"404\" type=\"NOT_FOUND\" field=\"user_id\"/>");
                return;
            }

            // Store the email and token in the session for later use
            session.token_user_id = email;
            // No need to update session.user_user_id, using database directly
            session.access_token = access_token;

            // Set the correct town filename based on the authenticated user's email
            bool use_legacy_mode = utils::configuration::ReadBoolean("Land", "UseLegacyMode", false);
            bool user_is_anonymous = email.find('@') == std::string::npos;

            std::string currency_path;
            std::string user_identifier;

            if (user_is_anonymous) {
                if (use_legacy_mode) {
                    // Legacy mode: all anonymous users share the same town file
                    session.town_filename = "mytown.pb";
                    currency_path = "towns/currency.txt";
                    user_identifier = "legacy_anonymous";
                    logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                        "[CURRENCY] Anonymous user detected, using legacy shared filename: %s",
                        session.town_filename.c_str());
                }
                else {
                    // Modern mode: each anonymous user gets a unique town file
                    session.town_filename = "anon_" + user_id + ".pb";
                    currency_path = "towns/anon_" + user_id + ".txt";
                    user_identifier = "anon_" + user_id;
                    logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                        "[CURRENCY] Anonymous user detected, using unique filename: %s",
                        session.town_filename.c_str());
                }
            }
            else {
                session.town_filename = email + ".pb";
                currency_path = "towns/" + email + ".txt";
                user_identifier = email;
            }

            std::filesystem::create_directories("towns");

            int balance = std::stoi(utils::configuration::ReadString("Server", "InitialDonutAmount", "1000"));
            if (std::filesystem::exists(currency_path)) {
                std::ifstream input(currency_path);
                if (input.good()) {
                    input >> balance;
                    logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                        "[CURRENCY] Loaded existing currency data for user: %s (Balance: %d)",
                        user_identifier.c_str(), balance);
                }
                input.close();
            }
            else {
                logger::write(logger::LOG_LEVEL_DEBUG, logger::LOG_LABEL_GAME,
                    "[CURRENCY] Creating new currency file for user: %s with initial balance: %d",
                    user_identifier.c_str(), balance);
            }

            int32_t total_earned = 0;
            int32_t total_spent = 0;
            Data::ExtraLandResponse response;

            for (const auto& delta : extraland_msg.currencydelta()) {
                if (delta.amount() > 0) {
                    total_earned += delta.amount();
                }
                else {
                    total_spent += std::abs(delta.amount());  //absolute value for spent amount
                }

                auto* processed = response.add_processedcurrencydelta();
                processed->set_id(delta.id());
            }

            balance = balance + total_earned - total_spent;

            std::ofstream output(currency_path);
            if (!output.is_open()) {
                throw std::runtime_error("Failed to open currency file for writing: " + currency_path);
            }
            output << balance;
            output.close();

            headers::set_protobuf_response(ctx);
            std::string serialized;
            if (response.SerializeToString(&serialized)) {
                cb(serialized);
            }
            else {
                throw std::runtime_error("Failed to serialize response");
            }

            logger::write(logger::LOG_LEVEL_RESPONSE, logger::LOG_LABEL_GAME,
                "[CURRENCY] Updated currency for user: %s (Balance: %d, Earned: %d, Spent: %d)",
                user_identifier.c_str(), balance, total_earned, total_spent);
        }
        catch (const std::exception& ex) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                "[CURRENCY] Error in extraland update: %s", ex.what());
            ctx->set_response_http_code(500);
            cb("");
        }
    }

    bool Land::load_town_by_email(const std::string& email) {
        auto& session = tsto::Session::get();
        auto& db = tsto::database::Database::get_instance();

        // If no valid access token or email is empty, always use mytown.pb
        if (email.empty() || session.access_token.empty()) {
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[LAND] No valid user found, defaulting to mytown.pb");
            std::string filename = "mytown.pb";
            session.town_filename = filename;
            return static_load_town();
        }

        // Always check the database first for the land save path
        std::string land_save_path;
        if (db.get_land_save_path(email, land_save_path) && !land_save_path.empty()) {
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[LAND] Using database land save path for %s: %s",
                email.c_str(), land_save_path.c_str());

            // Extract just the filename from the path
            session.town_filename = land_save_path.substr(land_save_path.find_last_of("/\\") + 1);
        }
        else {
            // If not found in database, create and store a default path
            std::string filename = email + ".pb";
            land_save_path = "towns/" + filename;
            session.town_filename = filename;

            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[LAND] Setting new database land save path for %s: %s",
                email.c_str(), land_save_path.c_str());

            if (db.update_land_save_path(email, land_save_path)) {
                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[LAND] Successfully updated land save path in database for %s", email.c_str());
            }
            else {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[LAND] Failed to update land save path in database for %s", email.c_str());
            }
        }

        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
            "[LAND] Loading town for email: %s (filename: %s)", email.c_str(), session.town_filename.c_str());

        return static_load_town();
    }

    bool Land::save_town_as(const std::string& email) {
        try {
            if (email.empty()) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[LAND] Cannot save town with empty email");
                return false;
            }

            auto& session = tsto::Session::get();
            auto& db = tsto::database::Database::get_instance();

            // Verify that the user has permission to save to this email
            if (email != "mytown" && !session.access_token.empty()) {
                std::string token_email;

                if (db.get_email_by_token(session.access_token, token_email)) {
                    if (token_email != email) {
                        logger::write(logger::LOG_LEVEL_WARN, logger::LOG_LABEL_GAME,
                            "[LAND] Access token belongs to %s but trying to save as %s - operation denied",
                            token_email.c_str(), email.c_str());
                        return false;
                    }
                }
                else {
                    // Token not found in database
                    logger::write(logger::LOG_LEVEL_WARN, logger::LOG_LABEL_GAME,
                        "[LAND] Access token not found in database - cannot save as %s", email.c_str());
                    return false;
                }
            }

            std::string filename = "towns/" + email + ".pb";
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[LAND] Saving town as: %s", filename.c_str());

            std::filesystem::create_directories("towns");

            std::string mayhem_id;
            if (!email.empty() && db.get_mayhem_id(email, mayhem_id) && !mayhem_id.empty()) {
                // Set the mayhem ID in the land proto
                session.land_proto.set_id(mayhem_id);
                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[LAND] Setting mayhem_id in land proto: %s", mayhem_id.c_str());
            }
            else {
                if (session.land_proto.id().empty()) {
                    std::string default_id = "90159726165211658982621159447878257465";
                    session.land_proto.set_id(default_id);
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[LAND] Set default ID for town: %s", default_id.c_str());
                }
                else {
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[LAND] Preserved existing ID for legacy town: %s", session.land_proto.id().c_str());
                }
            }

            std::string serialized;
            if (!session.land_proto.SerializeToString(&serialized)) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[LAND] Failed to serialize land proto");
                return false;
            }

            std::ofstream file(filename, std::ios::binary);
            if (!file.is_open()) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[LAND] Failed to open file for writing: %s", filename.c_str());
                return false;
            }

            file.write(serialized.data(), serialized.size());
            file.close();

            // Store the user ID in the database if we have one
            std::string user_id;
            bool has_user_id = false;

            // Get user_id from database using email
            if (!email.empty() && db.get_user_id(email, user_id) && !user_id.empty()) {
                has_user_id = true;
            }

            if (has_user_id) {
                // Get the current access token from the session
                std::string access_token = session.access_token;

                // Check if we already have an email associated with this token
                std::string existing_email;
                if (db.get_email_by_token(access_token, existing_email)) {
                    if (existing_email != email) {
                        // User is saving with a different email than what's associated with their token
                        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                            "[LAND] User with token is saving as new email: %s (previous: %s)",
                            email.c_str(), existing_email.c_str());

                        // Store the user ID with the new email but don't update the token association
                        if (!db.store_user_id(email, user_id, "", "", "")) {
                            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                                "[LAND] Failed to store user ID for email: %s", email.c_str());
                        }
                    }
                    else {
                        // Update the existing user record
                        if (!db.store_user_id(email, user_id, access_token, "", "")) {
                            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                                "[LAND] Failed to store user ID for email: %s", email.c_str());
                        }
                    }
                }
                else {
                    if (!db.store_user_id(email, user_id, access_token, "", "")) {
                        logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                            "[LAND] Failed to store user ID for email: %s", email.c_str());
                    }
                }
            }

            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[LAND] Town saved successfully as: %s", filename.c_str());
            return true;
        }
        catch (const std::exception& ex) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                "[LAND] Error saving town: %s", ex.what());
            return false;
        }
    }

    bool Land::copy_town(const std::string& source_email, const std::string& target_email) {
        if (source_email.empty() || target_email.empty()) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                "[LAND] Cannot copy town - source or target email is empty");
            return false;
        }

        if (source_email == target_email) {
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[LAND] Source and target emails are the same, no need to copy");
            return true;
        }

        auto& session = tsto::Session::get();

        // If no valid access token or email is empty, always use mytown.pb
        if (source_email.empty() || session.access_token.empty()) {
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[LAND] No valid user found, defaulting to mytown.pb");
            std::string filename = "mytown.pb";
            session.town_filename = filename;
            return static_load_town();
        }

        std::string filename = source_email + ".pb";
        session.town_filename = filename;

        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
            "[LAND] Loading town for email: %s (filename: %s)", source_email.c_str(), filename.c_str());

        if (!static_load_town()) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                "[LAND] Failed to load source town: %s", source_email.c_str());

            session.town_filename = "mytown.pb";
            static_load_town();

            return false;
        }

        bool result = save_town_as(target_email);

        if (result) {
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[LAND] Successfully copied town from %s to %s",
                source_email.c_str(), target_email.c_str());
        }
        else {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                "[LAND] Failed to save target town: %s", target_email.c_str());
        }

        session.town_filename = "mytown.pb";
        static_load_town();

        return result;
    }

    bool Land::import_town_file(const std::string& source_path, const std::string& email) {
        try {
            if (source_path.empty()) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[LAND] Cannot import town - source path is empty");
                return false;
            }

            if (!std::filesystem::exists(source_path)) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[LAND] Source file does not exist: %s", source_path.c_str());
                return false;
            }

            // If we have an email, check if we should delete any existing user with this email from the database
            if (!email.empty()) {
                auto& db = tsto::database::Database::get_instance();

                // Check configuration to see if we should delete existing users before import
                bool delete_existing_users = utils::configuration::ReadBoolean("Land", "DeleteExistingUsersOnImport", true);

                if (delete_existing_users) {
                    // Delete the user from the database
                    if (db.delete_user(email)) {
                        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                            "[LAND] Deleted existing user with email: %s before importing town", email.c_str());
                    }
                    else {
                        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                            "[LAND] No existing user found with email: %s or deletion failed", email.c_str());
                    }
                }
                else {
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[LAND] Skipping deletion of existing user with email: %s (DeleteExistingUsersOnImport=false)", email.c_str());
                }
            }

            std::filesystem::create_directories("towns");

            std::string dest_path;
            std::string currency_email;

            if (email.empty()) {
                dest_path = "towns/mytown.pb";
                currency_email = "default";
                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[LAND] No email provided, using default filename in towns directory: %s", dest_path.c_str());
            }
            else {
                dest_path = "towns/" + email + ".pb";
                currency_email = email;
                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[LAND] Using email-based filename: %s", dest_path.c_str());

                // Update the database with this path
                auto& db = tsto::database::Database::get_instance();
                if (!db.update_land_save_path(email, dest_path)) {
                    logger::write(logger::LOG_LEVEL_WARN, logger::LOG_LABEL_GAME,
                        "[LAND] Failed to update land save path in database for %s", email.c_str());
                }
            }

            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[LAND] Importing town from %s to %s", source_path.c_str(), dest_path.c_str());

            std::filesystem::copy_file(
                source_path,
                dest_path,
                std::filesystem::copy_options::overwrite_existing
            );

            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[LAND] File copied successfully");

            if (std::filesystem::exists(dest_path)) {
                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[LAND] Target file exists after copy: %s", dest_path.c_str());
            }
            else {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[LAND] Target file does not exist after copy: %s", dest_path.c_str());
            }

            if (source_path.find("temp/") == 0) {
                try {
                    std::filesystem::remove(source_path);
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[LAND] Deleted temporary file: %s", source_path.c_str());
                }
                catch (const std::exception& ex) {
                    logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                        "[LAND] Failed to delete temporary file: %s - %s", source_path.c_str(), ex.what());
                }
            }

            if (!currency_email.empty()) {
                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[LAND] Creating currency file for email: %s", currency_email.c_str());
                create_default_currency_file(currency_email);
            }

            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[LAND] Town imported successfully for %s", email.empty() ? "non-logged-in user" : ("email: " + email).c_str());
            return true;
        }
        catch (const std::exception& ex) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                "[LAND] Error importing town: %s", ex.what());
            return false;
        }
    }

    void Land::create_default_currency_file(const std::string& email) {
        if (email.empty()) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                "[CURRENCY] Cannot create currency file: email is empty");
            return;
        }

        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
            "[CURRENCY] Creating default currency file for email: %s", email.c_str());

        if (!std::filesystem::exists("towns")) {
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[CURRENCY] Creating towns directory");
            std::filesystem::create_directory("towns");
        }

        int default_donuts = std::stoi(utils::configuration::ReadString("Server", "InitialDonutAmount", "1000"));

        std::string currency_file;
        if (email == "default") {
            currency_file = "towns/currency.txt"; //mytown.pb, use currency.txt
        }
        else {
            currency_file = "towns/" + email + ".txt"; //email.pb, use email.txt
        }

        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
            "[CURRENCY] Currency file path: %s", currency_file.c_str());

        std::filesystem::path cwd = std::filesystem::current_path();
        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
            "[CURRENCY] Current working directory: %s", cwd.string().c_str());

        std::filesystem::path currency_path(currency_file);
        std::filesystem::path parent_path = currency_path.parent_path();
        if (!parent_path.empty() && !std::filesystem::exists(parent_path)) {
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[CURRENCY] Creating parent directory: %s", parent_path.string().c_str());
            std::filesystem::create_directories(parent_path);
        }

        try {
            std::ofstream out(currency_file);
            if (!out.is_open()) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[CURRENCY] Failed to open currency file for writing: %s", currency_file.c_str());
                return;
            }

            out << default_donuts;
            out.close();

            if (std::filesystem::exists(currency_file)) {
                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[CURRENCY] Currency file created successfully: %s with %d donuts",
                    currency_file.c_str(), default_donuts);
            }
            else {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[CURRENCY] Currency file does not exist after creation: %s", currency_file.c_str());
            }
        }
        catch (const std::exception& ex) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                "[CURRENCY] Exception creating currency file: %s", ex.what());
        }
    }

    void Land::handle_town_operations(evpp::EventLoop*, const evpp::http::ContextPtr& ctx,
        const evpp::http::HTTPSendResponseCallback& cb) {
        try {
            logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                "[TOWN OPS] Received request: RemoteIP: '%s', URI: '%s'",
                std::string(ctx->remote_ip()).c_str(),
                std::string(ctx->uri()).c_str());

            std::string body = ctx->body().ToString();
            rapidjson::Document doc;
            doc.Parse(body.c_str());

            if (doc.HasParseError()) {
                logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                    "[TOWN OPS] Invalid JSON in request body");
                headers::set_json_response(ctx);
                ctx->set_response_http_code(400);
                cb("{\"error\":\"Invalid JSON\"}");
                return;
            }

            if (doc.HasMember("operation") && doc["operation"].IsString() &&
                std::string(doc["operation"].GetString()) == "import") {

                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[TOWN OPS] Processing import operation");

                std::string email;
                if (doc.HasMember("email") && doc["email"].IsString()) {
                    email = doc["email"].GetString();
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[TOWN OPS] Email provided: %s", email.c_str());
                }
                else {
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[TOWN OPS] No email provided, using default filename");
                }

                if (!doc.HasMember("filePath") || !doc["filePath"].IsString()) {
                    logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                        "[TOWN OPS] Missing filePath in import request");
                    headers::set_json_response(ctx);
                    ctx->set_response_http_code(400);
                    cb("{\"error\":\"Missing filePath\"}");
                    return;
                }

                std::string temp_file_path = doc["filePath"].GetString();
                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[TOWN OPS] Temp file path: %s", temp_file_path.c_str());

                if (!std::filesystem::exists("towns")) {
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[TOWN OPS] Creating towns directory");
                    std::filesystem::create_directory("towns");
                }

                std::string target_file;
                std::string currency_email;

                if (email.empty()) {
                    target_file = "towns/mytown.pb";
                    currency_email = "default";
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[TOWN OPS] No email provided, using default filename in towns directory: %s", target_file.c_str());
                }
                else {
                    target_file = "towns/" + email + ".pb";
                    currency_email = email;
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[TOWN OPS] Using email-based filename: %s", target_file.c_str());
                }

                logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                    "[TOWN OPS] Target file path: %s", target_file.c_str());

                try {
                    if (!std::filesystem::exists(temp_file_path)) {
                        logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                            "[TOWN OPS] Source file does not exist: %s", temp_file_path.c_str());
                        headers::set_json_response(ctx);
                        ctx->set_response_http_code(500);
                        cb("{\"error\":\"Source file not found\"}");
                        return;
                    }

                    std::filesystem::path cwd = std::filesystem::current_path();
                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[TOWN OPS] Current working directory: %s", cwd.string().c_str());

                    std::filesystem::path target_path(target_file);
                    std::filesystem::path parent_path = target_path.parent_path();
                    if (!parent_path.empty() && !std::filesystem::exists(parent_path)) {
                        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                            "[TOWN OPS] Creating parent directory: %s", parent_path.string().c_str());
                        std::filesystem::create_directories(parent_path);
                    }

                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[TOWN OPS] Copying from %s to %s", temp_file_path.c_str(), target_file.c_str());

                    std::filesystem::copy_file(
                        temp_file_path,
                        target_file,
                        std::filesystem::copy_options::overwrite_existing
                    );

                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[TOWN OPS] File copied successfully");

                    if (std::filesystem::exists(target_file)) {
                        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                            "[TOWN OPS] Target file exists after copy: %s", target_file.c_str());
                    }
                    else {
                        logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                            "[TOWN OPS] Target file does not exist after copy: %s", target_file.c_str());
                    }

                    std::filesystem::remove(temp_file_path);

                    if (!currency_email.empty()) {
                        logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                            "[TOWN OPS] Creating currency file for email: %s", currency_email.c_str());
                        create_default_currency_file(currency_email);
                    }

                    logger::write(logger::LOG_LEVEL_INFO, logger::LOG_LABEL_GAME,
                        "[TOWN OPS] Town file imported successfully: %s", target_file.c_str());

                    headers::set_json_response(ctx);
                    cb("{\"success\":true,\"message\":\"Town imported successfully\"}");
                }
                catch (const std::exception& ex) {
                    logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                        "[TOWN OPS] Failed to import town file: %s", ex.what());
                    headers::set_json_response(ctx);
                    ctx->set_response_http_code(500);
                    cb("{\"error\":\"Failed to import town file: " + std::string(ex.what()) + "\"}");
                }
                return;
            }

        }
        catch (const std::exception& ex) {
            logger::write(logger::LOG_LEVEL_ERROR, logger::LOG_LABEL_GAME,
                "[TOWN OPS] Exception: %s", ex.what());
            headers::set_json_response(ctx);
            ctx->set_response_http_code(500);
            cb("{\"error\":\"Internal server error\"}");
        }
    }
}